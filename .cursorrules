# Meraki Dashboard Home Assistant Integration - Cursor Rules

## Project Context
This is a Home Assistant custom integration for Cisco Meraki Dashboard API, focusing on MT series environmental sensors with plans to expand to other device types.

## Code Style and Standards

### Python Style
- Follow PEP 8 with Home Assistant specific conventions
- Use type hints for all function parameters and return values
- Maximum line length: 88 characters (Black formatter)
- Use f-strings for string formatting
- Prefer early returns to reduce nesting
- Use descriptive variable names (no single letters except in comprehensions)

### Home Assistant Conventions
- Use async/await for all I/O operations
- Follow Home Assistant's entity naming conventions
- Use Home Assistant's logging standards
- Implement proper error handling with ConfigEntryAuthFailed and ConfigEntryNotReady
- Use Home Assistant's built-in helpers and utilities

### Documentation
- Every module, class, and public method must have docstrings
- Use Google-style docstrings format
- Include type information in docstrings
- Document all exceptions that can be raised
- Add inline comments for complex logic

### Integration Structure
- Follow Home Assistant's integration file structure
- Use manifest.json for integration metadata
- Implement config_flow for UI configuration
- Support both config entries and options flow
- Use update coordinators for efficient data fetching

### Testing
- Write tests for all new functionality
- Use pytest and Home Assistant's test helpers
- Mock external API calls
- Test both success and failure scenarios
- Maintain test coverage above 80%

### Git Conventions
- Use conventional commits format
- Keep commits atomic and focused
- Write clear, descriptive commit messages
- Reference issues in commit messages when applicable

## Key Patterns

### API Communication
- Always use the Meraki SDK, never direct API calls
- Implement proper rate limiting and error handling
- Use batch operations where possible
- Cache device information appropriately

### Entity Creation
- Create devices for physical hardware
- Create entities for individual metrics
- Use proper device classes and units
- Include all available attributes from API

### Configuration
- Support dynamic device discovery
- Allow users to select specific devices
- Make update intervals configurable
- Support runtime configuration changes

### Error Handling
- Log errors at appropriate levels
- Provide helpful error messages to users
- Implement retry logic for transient failures
- Handle API authentication errors gracefully

## Development Workflow
1. Make changes in feature branches
2. Run tests and linting before committing
3. Update documentation as needed
4. Test integration in actual Home Assistant instance
5. Submit PR with clear description of changes

## Common Tasks

### Adding New Sensor Types
1. Add metric constant to const.py
2. Add sensor description to sensor.py or binary_sensor.py
3. Update icons.json if needed
4. Test with actual device data

### Debugging
1. Enable debug logging in configuration.yaml
2. Check Home Assistant logs for errors
3. Use test_integration.py script for API testing
4. Monitor coordinator update cycles

### Performance Optimization
- Minimize API calls by using batch operations
- Respect Meraki's rate limits
- Use appropriate update intervals
- Implement efficient data structures

## Important Files
- `__init__.py` - Main integration setup and hub class
- `config_flow.py` - UI configuration flow
- `sensor.py` - Sensor platform implementation
- `binary_sensor.py` - Binary sensor platform implementation
- `const.py` - Constants and configuration keys
- `manifest.json` - Integration metadata
- `strings.json` - UI strings and translations 